use crate::{
    dto::entities::{
        airqualitymetrics::Model as AirQualityMetricsModel,
        devicemetrics::Model as DeviceMetricsModel,
        environmentmetrics::Model as EnvironmentMetricsModel,
        neighborinfo::Model as NeighborInfoModel,
    },
    util::types::{Mesh, Names},
};
use anyhow::{Context, Result};
use chrono::Utc;
#[cfg(feature = "debug")]
use log::error;
use meshtastic::protobufs::{
    AirQualityMetrics, DeviceMetrics, EnvironmentMetrics, NeighborInfo, Position,
};
use sea_orm::{
    ActiveModelBehavior, ActiveModelTrait, ConnectionTrait, DatabaseBackend, DatabaseConnection,
    EntityTrait, IntoActiveModel,
};
use std::marker::Send;

/// Insert row to a table
///
/// Generic function, no conflict resolution on insert
///
/// # Arguments
/// * `model` - The `Model` type generated by sea-orm
/// * `db` - The `DatabaseConnection` pool
/// * `metric_type` - `String` for the table metric name for error messages
///
/// # Returns
/// * Result with number of rows inserted
async fn insert_row_gen<T: Send + ActiveModelBehavior>(
    model: T,
    db: &DatabaseConnection,
    metric_type: String,
) -> Result<u32>
where
    <<T as ActiveModelTrait>::Entity as EntityTrait>::Model: IntoActiveModel<T>,
{
    match model.insert(db).await.with_context(|| {
        format!(
            "Failed to insert {} metrics row from mesh payload into {} db",
            metric_type,
            db.get_db_name()
        )
    }) {
        Ok(_) => Ok(1),
        Err(e) => {
            error!("{e}");
            Ok(0)
        }
    }
}

impl AirQualityMetricsModel {
    // Insert an Air Quality Metrics row
    //
    // This function proxies `insert_row_gen()` to leverage generics
    //
    // # Arguments
    // * `self` - A `AirQualityMetrics::Model` type
    // * `db` - A `DatabaseConnection` pool
    //
    // # Returns
    // * Result with number of rows inserted
    pub(crate) async fn insert_row(self, db: &DatabaseConnection) -> Result<u32> {
        insert_row_gen(self.into_active_model(), db, "air quality".to_string()).await
    }

    /// Create Air Quality Metrics Model
    ///
    /// # Arguments
    /// * `pkt` - a `Mesh` packet
    /// * `data` - `AirQualityMetrics` payload
    ///
    /// # Returns
    /// * An Air Quality Metrics Model
    #[must_use]
    pub(crate) fn create_model(pkt: &Mesh, data: AirQualityMetrics) -> Self {
        Self {
            msg_id: pkt.id,
            node_id: pkt.from,
            time: Utc::now().naive_utc(),
            pm10standard: data.pm10_standard,
            pm25standard: data.pm25_standard,
            pm100standard: data.pm100_standard,
            pm10environmental: data.pm10_environmental,
            pm25environmental: data.pm25_environmental,
            pm100environmental: data.pm100_environmental,
            particles03um: data.particles_03um,
            particles05um: data.particles_05um,
            particles10um: data.particles_10um,
            particles25um: data.particles_25um,
            particles50um: data.particles_50um,
            particles100um: data.particles_100um,
            co2: data.co2,
        }
    }
}

impl DeviceMetricsModel {
    // Insert an Device Metrics row
    //
    // This function proxies `insert_row_gen()` to leverage generics
    //
    // # Arguments
    // * `self` - A `DeviceMetrics::Model` type
    // * `db` - A `DatabaseConnection` pool
    //
    // # Returns
    // * Result with number of rows inserted
    pub(crate) async fn insert_row(self, db: &DatabaseConnection) -> Result<u32> {
        insert_row_gen(self.into_active_model(), db, "device".to_string()).await
    }

    /// Create Device Metrics Model for DeviceMetrics payloads
    ///
    /// # Arguments
    /// * `pkt` - a `Mesh` packet
    /// * `data` - `DeviceMetrics` payload
    ///
    /// # Returns
    /// * A Device Metrics Model
    pub(crate) fn create_dm_model(pkt: &Mesh, data: DeviceMetrics) -> Self {
        Self {
            msg_id: pkt.id,
            node_id: pkt.from,
            time: Utc::now().naive_utc(),
            battery_levels: data.battery_level,
            voltage: data.voltage,
            channelutil: data.channel_utilization,
            airutil: data.air_util_tx,
            latitude: None, //TODO: investigate default values
            longitude: None,
            longname: None,
            shortname: None,
            hwmodel: None,
        }
    }
}

impl EnvironmentMetricsModel {
    // Insert an Environment Metrics row
    //
    // This function proxies `insert_row_gen()` to leverage generics
    //
    // # Arguments
    // * `self` - A `EnvironmentMetrics::Model` type
    // * `db` - A `DatabaseConnection` pool
    //
    // # Returns
    // * Result with number of rows inserted
    pub(crate) async fn insert_row(self, db: &DatabaseConnection) -> Result<u32> {
        insert_row_gen(self.into_active_model(), db, "environment".to_string()).await
    }
    /// Create an Environmental Metrics Model
    ///
    /// # Arguments
    /// * `pkt` - a `Mesh` packet
    /// * `data` - `EnvironmentalMetrics` payload
    ///
    /// # Returns
    /// * An Environmental Metrics Model
    #[must_use]
    pub(crate) fn create_model(pkt: &Mesh, data: EnvironmentMetrics) -> Self {
        Self {
            msg_id: pkt.id,
            node_id: pkt.from,
            time: Utc::now().naive_utc(),
            relative_humidity: data.relative_humidity,
            tempurature: data.temperature,
            barometric_pressure: data.barometric_pressure,
            gas_resistance: data.gas_resistance,
            iaq: data.iaq,
            wind_direction: data.wind_direction,
            wind_gust: data.wind_gust,
            wind_speed: data.wind_speed,
            wind_lull: data.wind_lull,
            rainfall_1h: data.rainfall_1h,
            rainfall_24h: data.rainfall_24h,
        }
    }
}

impl NeighborInfoModel {
    // Insert an Neighbor Info row
    //
    // This function proxies `insert_row_gen()` to leverage generics
    //
    // # Arguments
    // * `self` - A `NeighborInfo::Model` type
    // * `db` - A `DatabaseConnection` pool
    //
    // # Returns
    // * Result with number of rows inserted
    pub(crate) async fn insert_row(self, db: &DatabaseConnection) -> Result<u32> {
        match db.get_database_backend() {
            DatabaseBackend::Sqlite => Ok(0),
            _ => insert_row_gen(self.into_active_model(), db, "neighborinfo".to_string()).await,
        }
    }

    /// Create an Neighbor Info Model
    ///
    /// # Arguments
    /// * `pkt` - a `Mesh` packet
    /// * `data` - `NeighborInfo` payload
    ///
    /// # Returns
    /// * A Neighbor Info Model
    #[must_use]
    pub(crate) fn create_model(pkt: &Mesh, data: NeighborInfo) -> Self {
        Self {
            msg_id: pkt.id,
            node_id: pkt.from,
            time: Utc::now().naive_utc(),
            last_sent_by_id: Some(data.last_sent_by_id),
            node_broadcast_interval_secs: Some(data.node_broadcast_interval_secs),
            neighbors: Some(
                data.neighbors
                    .into_iter()
                    .map(|n| n.node_id)
                    .collect::<Vec<u32>>(),
            ),
        }
    }
}
