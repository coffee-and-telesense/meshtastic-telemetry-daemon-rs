use crate::{
    dto::entities::{
        airqualitymetrics::Model as AirQualityMetricsModel,
        devicemetrics::Model as DeviceMetricsModel,
        environmentmetrics::Model as EnvironmentMetricsModel,
        errormetrics::Model as ErrorMetricsModel, localstats::Model as LocalStatsModel,
        neighborinfo::Model as NeighborInfoModel,
    },
    util::types::{ErrorCounts, Mesh, Names, Neighbor},
};
use anyhow::{Context, Result};
use chrono::Utc;
#[cfg(feature = "debug")]
use log::error;
use meshtastic::protobufs::{
    AirQualityMetrics, DeviceMetrics, EnvironmentMetrics, ErrorMetrics, LocalStats, NeighborInfo,
};
use sea_orm::{
    ActiveModelBehavior, ActiveModelTrait, ConnectionTrait, DatabaseBackend, DatabaseConnection,
    EntityTrait, IntoActiveModel,
};
use serde_json::{json, Value};
use std::marker::Send;

/// Insert row to a table
///
/// Generic function, no conflict resolution on insert
///
/// # Arguments
/// * `model` - The `Model` type generated by sea-orm
/// * `db` - The `DatabaseConnection` pool
/// * `metric_type` - `String` for the table metric name for error messages
///
/// # Returns
/// * Result with number of rows inserted
async fn insert_row_gen<T: Send + ActiveModelBehavior>(
    model: T,
    db: &DatabaseConnection,
    metric_type: String,
) -> Result<u32>
where
    <<T as ActiveModelTrait>::Entity as EntityTrait>::Model: IntoActiveModel<T>,
{
    match model.insert(db).await.with_context(|| {
        format!(
            "Failed to insert {} metrics row from mesh payload into {} db",
            metric_type,
            db.get_db_name()
        )
    }) {
        Ok(_) => Ok(1),
        Err(e) => {
            error!("{e:#}");
            Ok(0)
        }
    }
}

impl AirQualityMetricsModel {
    // Insert an Air Quality Metrics row
    //
    // This function proxies `insert_row_gen()` to leverage generics
    //
    // # Arguments
    // * `self` - A `AirQualityMetrics::Model` type
    // * `db` - A `DatabaseConnection` pool
    //
    // # Returns
    // * Result with number of rows inserted
    pub(crate) async fn insert_row(self, db: &DatabaseConnection) -> Result<u32> {
        insert_row_gen(self.into_active_model(), db, "air quality".to_string()).await
    }

    /// Create Air Quality Metrics Model
    ///
    /// # Arguments
    /// * `pkt` - a `Mesh` packet
    /// * `data` - `AirQualityMetrics` payload
    ///
    /// # Returns
    /// * An Air Quality Metrics Model
    #[must_use]
    pub(crate) fn create_model(pkt: &Mesh, data: AirQualityMetrics) -> Self {
        Self {
            msg_id: pkt.id,
            node_id: pkt.from,
            time: Utc::now().naive_utc(),
            pm10standard: data.pm10_standard,
            pm25standard: data.pm25_standard,
            pm100standard: data.pm100_standard,
            pm10environmental: data.pm10_environmental,
            pm25environmental: data.pm25_environmental,
            pm100environmental: data.pm100_environmental,
            particles03um: data.particles_03um,
            particles05um: data.particles_05um,
            particles10um: data.particles_10um,
            particles25um: data.particles_25um,
            particles50um: data.particles_50um,
            particles100um: data.particles_100um,
            co2: data.co2,
            sensor_type: data.sensor,
        }
    }
}

impl DeviceMetricsModel {
    // Insert an Device Metrics row
    //
    // This function proxies `insert_row_gen()` to leverage generics
    //
    // # Arguments
    // * `self` - A `DeviceMetrics::Model` type
    // * `db` - A `DatabaseConnection` pool
    //
    // # Returns
    // * Result with number of rows inserted
    pub(crate) async fn insert_row(self, db: &DatabaseConnection) -> Result<u32> {
        insert_row_gen(self.into_active_model(), db, "device".to_string()).await
    }

    /// Create Device Metrics Model for `DeviceMetrics` payloads
    ///
    /// # Arguments
    /// * `pkt` - a `Mesh` packet
    /// * `data` - `DeviceMetrics` payload
    ///
    /// # Returns
    /// * A Device Metrics Model
    pub(crate) fn create_dm_model(pkt: &Mesh, data: DeviceMetrics) -> Self {
        Self {
            msg_id: pkt.id,
            node_id: pkt.from,
            time: Utc::now().naive_utc(),
            battery_levels: data.battery_level,
            voltage: data.voltage,
            channelutil: data.channel_utilization,
            airutil: data.air_util_tx,
            latitude: None, //TODO: investigate default values
            longitude: None,
            longname: None,
            shortname: None,
            hwmodel: None,
        }
    }
}

impl EnvironmentMetricsModel {
    // Insert an Environment Metrics row
    //
    // This function proxies `insert_row_gen()` to leverage generics
    //
    // # Arguments
    // * `self` - A `EnvironmentMetrics::Model` type
    // * `db` - A `DatabaseConnection` pool
    //
    // # Returns
    // * Result with number of rows inserted
    pub(crate) async fn insert_row(self, db: &DatabaseConnection) -> Result<u32> {
        insert_row_gen(self.into_active_model(), db, "environment".to_string()).await
    }
    /// Create an Environmental Metrics Model
    ///
    /// # Arguments
    /// * `pkt` - a `Mesh` packet
    /// * `data` - `EnvironmentalMetrics` payload
    ///
    /// # Returns
    /// * An Environmental Metrics Model
    #[must_use]
    pub(crate) fn create_model(pkt: &Mesh, data: EnvironmentMetrics) -> Self {
        Self {
            msg_id: pkt.id,
            node_id: pkt.from,
            time: Utc::now().naive_utc(),
            relative_humidity: data.relative_humidity,
            tempurature: data.temperature,
            barometric_pressure: data.barometric_pressure,
            gas_resistance: data.gas_resistance,
            iaq: data.iaq,
            wind_direction: data.wind_direction,
            wind_gust: data.wind_gust,
            wind_speed: data.wind_speed,
            wind_lull: data.wind_lull,
            rainfall_1h: data.rainfall_1h,
            rainfall_24h: data.rainfall_24h,
            sensor_type: data.sensor,
        }
    }
}

impl ErrorMetricsModel {
    // Insert an Error Metrics row
    //
    // This function proxies `insert_row_gen()` to leverage generics
    //
    // # Arguments
    // * `self` - A `ErrorMetrics::Model` type
    // * `db` - A `DatabaseConnection` pool
    //
    // # Returns
    // * Result with number of rows inserted
    pub(crate) async fn insert_row(self, db: &DatabaseConnection) -> Result<u32> {
        match db.get_database_backend() {
            DatabaseBackend::Sqlite => Ok(0),
            _ => insert_row_gen(self.into_active_model(), db, "errormetrics".to_string()).await,
        }
    }
    /// Create an Error Metrics Model
    ///
    /// # Arguments
    /// * `pkt` - a `Mesh` packet
    /// * `data` - `ErrorMetrics` payload
    ///
    /// # Returns
    /// * A Error Metrics Model
    #[must_use]
    pub(crate) fn create_model(pkt: &Mesh, data: ErrorMetrics) -> Self {
        Self {
            msg_id: pkt.id,
            node_id: pkt.from,
            time: Utc::now().naive_utc(),
            collision_rate: data.collision_rate,
            node_reach: data.node_reach,
            num_nodes: data.num_nodes,
            usefulness: data.usefulness,
            avg_delay: data.avg_delay,
            period: data.period,
            errors: Some(json!(&ErrorCounts {
                no_routes: data.noroute,
                naks: data.naks,
                timeouts: data.timeouts,
                max_retransmits: data.max_retransmit,
                no_channels: data.no_channel,
                too_large: data.too_large
            })),
        }
    }
}

impl LocalStatsModel {
    // Insert a Local Stats row
    //
    // This function proxies `insert_row_gen()` to leverage generics
    //
    // # Arguments
    // * `self` - A `LocalStats::Model` type
    // * `db` - A `DatabaseConnection` pool
    //
    // # Returns
    // * Result with number of rows inserted
    pub(crate) async fn insert_row(self, db: &DatabaseConnection) -> Result<u32> {
        insert_row_gen(self.into_active_model(), db, "local stats".to_string()).await
    }

    /// Create a Local Stats Model
    ///
    /// # Arguments
    /// * `pkt` - a `Mesh` packet
    /// * `data` - `LocalStats` payload
    ///
    /// # Returns
    /// * A Local Stats Model
    #[must_use]
    pub(crate) fn create_model(pkt: &Mesh, data: LocalStats) -> Self {
        Self {
            msg_id: pkt.id,
            node_id: pkt.from,
            time: Utc::now().naive_utc(),
            uptime_seconds: Some(data.uptime_seconds),
            channel_util: Some(data.channel_utilization),
            air_util_tx: Some(data.air_util_tx),
            num_packets_tx: Some(data.num_packets_tx),
            num_packets_rx: Some(data.num_packets_rx),
            num_packets_rx_bad: Some(data.num_packets_rx_bad),
            num_online_nodes: Some(data.num_online_nodes),
            num_total_nodes: Some(data.num_total_nodes),
            num_rx_dupe: Some(data.num_rx_dupe),
            num_tx_relay: Some(data.num_tx_relay),
            num_tx_relay_canceled: Some(data.num_tx_relay_canceled),
        }
    }
}

impl NeighborInfoModel {
    // Insert an Neighbor Info row
    //
    // This function proxies `insert_row_gen()` to leverage generics
    //
    // # Arguments
    // * `self` - A `NeighborInfo::Model` type
    // * `db` - A `DatabaseConnection` pool
    //
    // # Returns
    // * Result with number of rows inserted
    pub(crate) async fn insert_row(self, db: &DatabaseConnection) -> Result<u32> {
        match db.get_database_backend() {
            DatabaseBackend::Sqlite => Ok(0),
            _ => insert_row_gen(self.into_active_model(), db, "neighborinfo".to_string()).await,
        }
    }

    /// Create an Neighbor Info Model
    ///
    /// # Arguments
    /// * `pkt` - a `Mesh` packet
    /// * `data` - `NeighborInfo` payload
    ///
    /// # Returns
    /// * A Neighbor Info Model
    #[must_use]
    pub(crate) fn create_model(pkt: &Mesh, data: NeighborInfo) -> Self {
        Self {
            msg_id: pkt.id,
            node_id: pkt.from,
            time: Utc::now().naive_utc(),
            last_sent_by_id: Some(data.last_sent_by_id),
            node_broadcast_interval_secs: Some(data.node_broadcast_interval_secs),
            neighbors: Some(
                data.neighbors
                    .into_iter()
                    .map(|n| {
                        json!(&Neighbor {
                            node_id: n.node_id,
                            snr: n.snr,
                        })
                    })
                    .collect::<Vec<Value>>(),
            ),
        }
    }
}
